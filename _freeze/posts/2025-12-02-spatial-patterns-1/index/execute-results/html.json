{
  "hash": "e9183ea06a70da0a05ee37c74384f4a3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Spatial Patterns and Random Fields I\"\ndate: 2025-12-02\ncategories: [landscape ecology, spatial patterns]\nformat:\n  html:\n    toc: true\n---\n\n# Introduction\n\n\n::: {.cell}\n\n:::\n\n\nLandscapes contain myriad spatial patterns. These patterns interest us because of their implications for a variety of ecological processes. Here I treat landscapes as random fields and examine the spatial patterns the arise from them. A random field treats a lattice as a continuous surface; a vegetation gradient. Patterns arise on this surface by creating random noise and then smoothing it based on correlation distances.\n\n> White noise has structure inside it; smoothing reveals it.\n\nThe objectives of this exercise are to 1. learn to generate random fields, and 2. learn the methods of summarise them (spatial variance, correlation lengths).\n\n# Noisy Field\n\nSuppose we have a square lattice of size $N \\times N$ where $i = 1,...,N$ and $j = 1,...,N$. Each cell of this lattice has a coordinate $(i,j)$. We begin by generating a very noisy random field made up of Gaussian noise at each cell location\n\n$$\n\\begin{align}\n\\varepsilon(i,j) \\sim \\mathcal{N}(0,\\sigma^2), \\qquad \\text{independent for all }(i,j).\n\\end{align}\n$$ We can think of $\\varepsilon(i,j)$ as the \"speckling\" of the grid. This speckling has no spatial pattern that is qualitatively evident.\n\n## Gaussian Kernel\n\nNext we define a kernel $K_{\\ell}(\\Delta i, \\Delta j)$ that depends on the differences between a pair of cells in the lattice. To start, we use a Guassian kernel\n\n$$\n\\begin{align}\nK_{\\ell}(\\Delta i, \\Delta j) = \\text{exp}\\biggl(\\frac{\\Delta i^2 + \\Delta j^2)}{2\\ell^2}\\biggr).\n\\end{align}\n$$ The notation $\\Delta i$ and $\\Delta j$ capture the differences between the values at cell locations. The locations of these comparison cells are $(u,v)$, with $\\Delta i = i - u$ and $\\Delta j = j - v$. Here $\\ell$ is a scale parameter that controls the correlation length.\n\n-   When $\\ell$ is small, the patterns are peaked and rugged.\n\n-   When $\\ell$ is large, the patterns are smoother, averaged over many neighbors.\n\n## Convolution\n\nTo construct the random field $X(i,j)$, we smooth over the noisy field $\\varepsilon(i,j)$ using the chosen Gaussian kernel function. Mathematically, this looks like\n\n$$\n\\begin{align}\nX(i,j) = \\sum^N_{u=1} \\sum^N_{v=1} K_{\\ell}(i-u,\\ j-v)\\varepsilon(u,v)\n\\end{align}\n$$\n\nFor each focal cell $(i,j)$, we examine a reference pixel $(u,v)$ and compute the difference. This is used to assign a weight $w = K_{\\ell}(\\Delta i, \\Delta j)$ that is multiplied by the noise $\\varepsilon(u,v)$. We sum over these such that $X(i,j)$ is a weighted average.\n\n# Simulation\n\nIn code, we have two sets of loops: one over $(i,j)$ and a second over $(u,v)$. But first, we generate the noisy field.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(latex2exp)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'latex2exp' was built under R version 4.3.3\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(patchwork)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'patchwork' was built under R version 4.3.3\n```\n\n\n:::\n\n```{.r .cell-code}\nset.seed(777)\nN = 50\nsigma = 1\n  \neps = matrix(0, N, N)\nfor(i in 1:N) for(j in 1:N) {\n  eps[i,j] = rnorm(1, 0, sigma)\n}\n\npal1 = colorRampPalette(c('#0F0E0E','#4D2D8C','#FF714B','#FAD691'))\npal2 = colorRampPalette(c('#0F0E0E','#0033ff','#00cc00','#FAD691'))\n\ndat = expand.grid(i=1:nrow(eps), j=1:ncol(eps)) |>  \n  mutate(eps = as.vector(eps))\n\nggplot(dat, aes(x=j,y=i, fill=eps) ) + \n  geom_tile() + \n  scale_fill_gradientn(colours = pal1(N)) + \n  coord_fixed() + \n  labs(fill = expression(epsilon)) + \n  \n  theme(panel.background = element_rect(color='black', fill=NA, size=2))\n```\n\n::: {.cell-output-display}\n![An example of $\\varepsilon(i,j)$.](index_files/figure-html/unnamed-chunk-2-1.png){width=384}\n:::\n:::\n\n\nWe then apply the smoothing kernel over this noise to obtain $X(i,j)$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nell = 3\nX = matrix(0, N, N)\nfor(i in 1:N) for(j in 1:N) {\n  \n  total = 0\n  \n  for(u in 1:N) for(v in 1:N) {\n    \n    dx = i - u\n    dy = j - v\n    \n    d2 = dx*dx + dy*dy\n    \n    w = exp(-d2 / (2 * ell * ell))\n    \n    total = total + w * eps[u,v]\n  }\n  X[i,j] = total\n}\n\n\ndat = expand.grid(i=1:nrow(eps), j=1:ncol(eps)) |>  \n  mutate(X = as.vector(X))\n\nggplot(dat, aes(x=j,y=i, fill=X) ) + \n  geom_tile() + \n  scale_fill_gradientn(colours = pal1(N)) + \n  coord_fixed() + \n  labs(fill = 'X') + \n   \n  theme(panel.background = element_rect(color='black', fill=NA, size=2))\n```\n\n::: {.cell-output-display}\n![An example of $X(i,j)$.](index_files/figure-html/unnamed-chunk-3-1.png){width=384}\n:::\n:::\n\n\nChanging the value of $\\ell$ will adjust the spatial pattern as described above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nsimulate_grf = function(N = 50, \n                        sigma, \n                        ell) {\n  \n  # white noise field \n  eps = matrix(0, N, N)\n  for(i in 1:N) for(j in 1:N) {\n    eps[i,j] = rnorm(1, 0, sigma)\n  }\n  \n  # output field \n  X = matrix(0, N, N)\n  for(i in 1:N) for(j in 1:N) {\n    \n    total = 0\n    \n    for(u in 1:N) for(v in 1:N) {\n      \n      dx = i - u\n      dy = j - v\n      \n      d2 = dx*dx + dy*dy\n      \n      # Gaussian kernel \n      w = exp(-d2 / (2 * ell * ell))\n      \n      total = total + w * eps[u,v]\n      \n    }\n    \n    X[i,j] = total\n  }\n  return(X)\n}\n\nell_seq = 1:4\nX_list = list()\nfor(k in 1:length(ell_seq)) {\n  x = simulate_grf(N, sigma = 1, ell = ell_seq[k])\n  df = expand.grid(i = 1:nrow(x), j = 1:ncol(x)) |> \n    mutate(value = as.vector(x), \n           ell = paste('\\u2113','=',ell_seq[k]))\n  X_list[[k]] = df\n}\n\ndf = bind_rows(X_list)\n\np1 = ggplot(df, aes(x=j, y=i, fill=value)) + \n  geom_tile() + \n  scale_fill_gradientn(colours = pal1(N)) + \n  facet_wrap(~ell) +\n  labs(fill = 'X') + \n   \n  theme(panel.background = element_rect(color='black', fill=NA, size=2))\n\np1\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=576}\n:::\n:::\n\n\n## Correlation Function\n\nWe can express the surface $X(i,j)$ as a correlation surface $\\hat{C}(h,k)$ where $(h,k)$ is some spatial lag. The function to compute this is\n\n$$\n\\begin{align}\n\\hat{C}(h,k) = \\frac{1}{N_{h,k}} \\sum^{N-h}_{i=1} \\sum^{N-k}_{j=1} \\frac{(X(i,j) - \\bar{X})(X(i+h,j+k)-\\bar{X}}{\\hat{\\sigma}^2}\n\\end{align}\n$$\n\nThis equation centers the values of $X(i,j)$ using the mean $\\bar{X}$, then centers the difference between $X(i,j)$ and $X(h,k)$. This expression is then rescaled by the variance $\\hat{\\sigma}^2$. The fraction $\\frac{1}{N_{h,k}}$ identifies the valid pairs to compare after the differences are summed over.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncorr_surface = function(X) {\n  N = nrow(X)\n  meanX = mean(X)\n  varX  = var(as.vector(X))\n  \n  C = matrix(0, N, N)\n  \n  for(h in 0:(N-1)) for(k in 0:(N-1)) {\n    \n    total = 0\n    count = 0\n    \n    for(i in 1:(N-h)) for(j in 1:(N-k)) {\n      \n      a = X[i,j] - meanX\n      b = X[i+h,j+k] - meanX\n      \n      total = total + (a * b)\n      count = count + 1\n      \n    }\n    C[h+1,k+1] = total / (count * varX)\n  }\n  return(C)\n}\n\nX = simulate_grf(N = 50, ell = 2, sigma = 1)\nC = corr_surface(X)\n\ncorr_df = expand.grid(i = 1:nrow(C), j = 1:ncol(C)) |> \n  mutate(C = as.vector(C), \n         X = as.vector(X))\n\nggplot(corr_df, aes(x=j, y=i, fill=X)) + \n  geom_tile() + \n  scale_fill_gradientn(colours = pal1(N)) + \n  coord_fixed() + \n  labs(fill = 'X') + \n  \n  theme(panel.background = element_rect(color='black', fill=NA, size=2)) +\n\nggplot(corr_df, aes(x=j, y=i, fill=C)) + \n  geom_tile() + \n  scale_fill_gradientn(colours = pal2(N)) + \n  coord_fixed() + \n  labs(fill = 'C') + \n  \n  theme(panel.background = element_rect(color='black', fill=NA, size=2))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nWith the correlation surface in hand, we can reduce it to a correlation function by first defining the distance between each pair\n\n$$\n\\begin{align}\nd(h,k) = \\sqrt{h^2 + k^2}.\n\\end{align}\n$$\n\nIn code, this looks like\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhk = expand.grid(\n  h = 0:(N-1), \n  k = 0:(N-1)\n)\n\nhk$d = sqrt(hk$h^2 + hk$k^2)\n```\n:::\n\n\nWe then define bins for the distance and compute the average correlation within each bin\n\n$$\n\\begin{align}\n\\hat{C}(d) = \\text{mean} \\biggl\\{\\hat{C}(h,k):(h,k) \\in B_d \\biggr\\}.\n\\end{align}\n$$\n\nHere we define the distance bins using `delta` to define the intervals of interest. If `delta = 1`, this is the same as rounding down the distances using `floor`. Plug in the surface from `corr_surface` and average the correlations within each bin, along with the number of pairs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncorr_distance = function(C, delta=1, min_pairs = NULL) {\n  N = nrow(C)\n  \n  # define the grid\n  hk = expand.grid(\n    h = 0:(N-1), \n    k = 0:(N-1)\n  )\n  \n  # sqrt of distance \n  hk$d = sqrt(hk$h^2 + hk$k^2)\n  hk$C = as.vector(C)\n  \n  # distance bins \n  maxd = max(hk$d)\n  centers = seq(0, maxd, by=delta)\n  \n  cd = data.frame(\n    distance = centers, \n    corr     = NA, \n    n_pairs  = NA\n    )\n  \n  for(idx in seq_along(centers)) {\n    d0 = centers[idx]\n    # find distances within the bin\n    in_bin = abs(hk$d - d0) < (delta / 2)\n    vals = hk$C[in_bin]\n    \n    if(length(vals) > 0) {\n      cd$corr[idx]    = mean(vals)\n      cd$n_pairs[idx] = length(vals)\n    } else {\n      cd$corr[idx]    = NA\n      cd$n_pairs      = 0\n    }\n  }\n  \n  if(!is.null(min_pairs)) {\n    cd = cd |> filter(n_pairs >= min_pairs)\n  } \n  return(cd)\n}\n\ncd = corr_distance(C, delta = 1)\n\nggplot(cd, aes(x=distance, y=corr)) + \n  geom_line(size=1, color='red') + \n  labs(x = 'd', y = TeX(\"$\\\\hat{C}(d)$\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nâ„¹ Please use `linewidth` instead.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nThe graph shows that cells which are close together in space are highly correlated, that this correlation decays rapidly, but it oscillates. This can indicate some quasi-periodicity in the spatial patterns.\n\nWe can now apply this function to different spatial patterns generated by varying the value of $\\ell$, and compare the correlation distances.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nell_seq = 1:4\nC_list = list()\nfor(k in 1:length(ell_seq)) {\n  x = simulate_grf(N, sigma = 1, ell = ell_seq[k])\n  c = corr_surface(x)\n  d = corr_distance(c, delta = 1)\n  d$ell = k\n  C_list[[k]] = d\n}\n\ncp = bind_rows(C_list) |> \n  ggplot(aes(x=distance, y=corr, color = factor(ell))) + \n  geom_line(size=1) + \n  labs(color = '\\u2113', x = 'd', y = TeX(\"$\\\\hat{C}(d)$\")) \n\np1 / cp + plot_layout(heights = c(2.75,1.5))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=576}\n:::\n:::\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}