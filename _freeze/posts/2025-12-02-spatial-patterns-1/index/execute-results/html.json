{
  "hash": "ebe63ad069074d738d466d80e585c31b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Spatial Patterns and Random Fields I\"\ndate: 2025-12-02\ncategories: [landscape ecology, spatial patterns]\nformat:\n  html:\n    toc: true\n---\n\n# Introduction\n\n\n::: {.cell}\n\n:::\n\n\nLandscapes contain myriad spatial patterns. These patterns interest us because of their implications for a variety of ecological processes. Here I treat landscapes as random fields and examine the spatial patterns the arise from them. A random field treats a lattice as a continuous surface; a vegetation gradient. Patterns arise on this surface by creating random noise and then smoothing it based on correlation distances.\n\n> White noise has structure inside it; smoothing reveals it.\n\nThe objectives of this exercise are to 1) learn to generate random fields, and 2) learn the methods of summarise them (spatial variance, correlation lengths).\n\n# Noisy Field\n\nSuppose we have a square lattice of size $N \\times N$ where $i = 1,...,N$ and $j = 1,...,N$. Each cell of this lattice has a coordinate $(i,j)$. We begin by generating a very noisy random field made up of Gaussian noise at each cell location\n\n$$\n\\begin{align}\n\\varepsilon(i,j) \\sim \\mathcal{N}(0,\\sigma^2), \\qquad \\text{independent for all }(i,j).\n\\end{align}\n$$ We can think of $\\varepsilon(i,j)$ as the \"speckling\" of the grid. This speckling has no spatial pattern that is qualitatively evident.\n\n## Gaussian Kernel\n\nNext we define a kernel $K_{\\ell}(\\Delta i, \\Delta j)$ that depends on the differences between a pair of cells in the lattice. To start, we use a Guassian kernel\n\n$$\n\\begin{align}\nK_{\\ell}(\\Delta i, \\Delta j) = \\text{exp}\\biggl(\\frac{\\Delta i^2 + \\Delta j^2)}{2\\ell^2}\\biggr).\n\\end{align}\n$$ The notation $\\Delta i$ and $\\Delta j$ capture the differences between the values at cell locations. The locations of these comparison cells are $(u,v)$, with $\\Delta i = i - u$ and $\\Delta j = j - v$. Here $\\ell$ is a scale parameter that controls the correlation length.\n\n-   When $\\ell$ is small, the patterns are peaked and rugged.\n\n-   When $\\ell$ is large, the patterns are smoother, averaged over many neighbors.\n\n## Convolution\n\nTo construct the random field $X(i,j)$, we smooth over the noisy field $\\varepsilon(i,j)$ using the chosen Gaussian kernel function. Mathematically, this looks like\n\n$$\n\\begin{align}\nX(i,j) = \\sum^N_{u=1} \\sum^N_{v=1} K_{\\ell}(i-u,\\ j-v)\\varepsilon(u,v)\n\\end{align}\n$$\n\nFor each focal cell $(i,j)$, we examine a reference pixel $(u,v)$ and compute the difference. This is used to assign a weight $w = K_{\\ell}(\\Delta i, \\Delta j)$ that is multiplied by the noise $\\varepsilon(u,v)$. We sum over these such that $X(i,j)$ is a weighted average.\n\n# Simulation\n\nIn code, we have two sets of loops: one over $(i,j)$ and a second over $(u,v)$. But first, we generate the noisy field.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(latex2exp)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'latex2exp' was built under R version 4.3.3\n```\n\n\n:::\n\n```{.r .cell-code}\nN = 50\nsigma = 1\n  \neps = matrix(0, N, N)\nfor(i in 1:N) for(j in 1:N) {\n  eps[i,j] = rnorm(1, 0, sigma)\n}\n\npal = colorRampPalette(c('#0F0E0E','#4D2D8C','#FF714B','#FAD691'))\n\ndat = expand.grid(i=1:nrow(eps), j=1:ncol(eps)) |>  \n  mutate(eps = as.vector(eps))\n\nggplot(dat, aes(x=j,y=i, fill=eps) ) + \n  geom_tile() + \n  scale_fill_gradientn(colours = pal(N)) + \n  coord_fixed() + \n  labs(fill = expression(epsilon)) + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![An example of $\\varepsilon(i,j)$.](index_files/figure-html/unnamed-chunk-2-1.png){width=384}\n:::\n:::\n\n\nWe then apply the smoothing kernel over this noise to obtain $X(i,j)$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nell = 3\nX = matrix(0, N, N)\nfor(i in 1:N) for(j in 1:N) {\n  \n  total = 0\n  \n  for(u in 1:N) for(v in 1:N) {\n    \n    dx = i - u\n    dy = j - v\n    \n    d2 = dx*dx + dy*dy\n    \n    w = exp(-d2 / (2 * ell * ell))\n    \n    total = total + w * eps[u,v]\n  }\n  X[i,j] = total\n}\n\n\ndat = expand.grid(i=1:nrow(eps), j=1:ncol(eps)) |>  \n  mutate(X = as.vector(X))\n\nggplot(dat, aes(x=j,y=i, fill=X) ) + \n  geom_tile() + \n  scale_fill_gradientn(colours = pal(N)) + \n  coord_fixed() + \n  labs(fill = 'X') + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![An example of $X(i,j)$.](index_files/figure-html/unnamed-chunk-3-1.png){width=384}\n:::\n:::\n\n\nChanging the value of $\\ell$ will adjust the spatial pattern as described above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nsimulate_grf = function(N = 50, \n                        sigma, \n                        ell) {\n  \n  # white noise field \n  eps = matrix(0, N, N)\n  for(i in 1:N) for(j in 1:N) {\n    eps[i,j] = rnorm(1, 0, sigma)\n  }\n  \n  # output field \n  X = matrix(0, N, N)\n  for(i in 1:N) for(j in 1:N) {\n    \n    total = 0\n    \n    for(u in 1:N) for(v in 1:N) {\n      \n      dx = i - u\n      dy = j - v\n      \n      d2 = dx*dx + dy*dy\n      \n      # Gaussian kernel \n      w = exp(-d2 / (2 * ell * ell))\n      \n      total = total + w * eps[u,v]\n      \n    }\n    \n    X[i,j] = total\n  }\n  return(X)\n}\n\nell_seq = 1:4\nX_list = list()\nfor(k in 1:length(ell_seq)) {\n  x = simulate_grf(N, sigma = 1, ell = ell_seq[k])\n  df = expand.grid(i = 1:nrow(x), j = 1:ncol(x)) |> \n    mutate(value = as.vector(x), \n           ell = paste('\\u2113','=',ell_seq[k]))\n  X_list[[k]] = df\n}\n\ndf = bind_rows(X_list)\n\nggplot(df, aes(x=j, y=i, fill=value)) + \n  geom_tile() + \n  scale_fill_gradientn(colours = pal(N)) + \n  coord_fixed() + \n  facet_wrap(~ell) +\n  labs(fill = 'X') + \n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=576}\n:::\n:::\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}