{
  "hash": "8c00c78f092a9525ddc75dbcdacb6a82",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Local Facilitation Model\"\ndraft: true\n---\n\n\n::: {.cell}\n\n:::\n\n\n\n# Local Facilitation Model\n\nLet $s_i(t) \\in \\{0,1\\}$ be the state of a cell $i$, and $n_i = \\sum_{j \\in A(i)} s_j$, where $A(i)$ is the adjacency set of $i$ based on a user-defined neighborhood (e.g., von Neumann, Moore, disk).\n\nWithin the local neighborhood, we compute the fraction of occupied sites adjacent to $i$.\n\n$$\n\\begin{equation}\n\\bar{n}_i = \\frac{1}{|A(i)|} \\sum_{j \\in A(i)} s_j\n\\end{equation}\n$$\n\nThis encodes the local facilitation. Whether $i$ changes state depends on the facilitation effect itself.\n\n$$\n\\begin{equation}\n\\textbf{Pr}[s_i(t+1) = 1 \\ | \\ s_i(t) = 0] = \\alpha + \\beta f(\\bar{n}_i)\n\\end{equation}\n$$\n\nThe probability that $s_i = 1$ at time $t+1$ given that $s_i(t) = 0$ depends on the global propensity to change state, $\\alpha$, and the strength of the facilitation, $\\beta$. The function $f$ controls the form of this strength (e.g., linear, saturating, etc). In other words, empty sites are more likely to become occupied if their neighbors are occupied.\n\nThen the probability that an occupied site becomes unoccupied is controlled by a mortality function\n\n$$\n\\begin{equation}\n\\textbf{Pr}[s_i(t+1) = 0 \\ | \\ s_i(t) = 1] = \\mu\n\\end{equation}\n$$ \n\nwhere $\\mu$ controls the mortality rate.\n\nAt the landscape level, the mean-field approximation is\n\n$$\n\\begin{equation}\n\\frac{d\\rho}{dt} = (\\alpha + \\beta \\rho)(1 - \\rho) - \\mu \\rho\n\\end{equation}\n$$\n\nwhere $\\rho$ is the overall vegetation cover. This can be understood as a kind of feedback based percolation model as there is no diffusion process, no conservation, no resource constraints.\n\nIf $s_i \\in \\{1,...,q\\}$, then we define indicator variables\n\n$$\n\\begin{equation}\n\\mathbb{I}(s_j = k), \\qquad k = 1,...,q\n\\end{equation}\n$$\n\nsuch that\n\n$$\n\\begin{equation}\nn_{ik} = \\frac{1}{|A(i)|} \\sum_{j \\in A(i)} \\mathbb{I}(s_j = k)\n\\end{equation}\n$$\n\nIn this case, $\\textbf{n}_i$ is a local state frequency vector. The transition probabilities from one state to another can be defined by\n\n$$\n\\begin{equation}\n\\textbf{Pr}[s_i(t+1) = k] \\propto \\alpha_k + \\sum^q_{\\ell = 1} \\beta_{k\\ell} n_{i\\ell}\n\\end{equation}\n$$\n\nHowever, there is a decision to make here. Can $s_i$ really transition into any other state? Or does $s_i$ progress through states? For instance\n\n$$\ns_2 \\leftarrow s_1 \\rightarrow s_3 \\qquad \\text{versus} \\qquad s_1 \\rightarrow s_2 \\rightarrow s_3\n$$ \n\nFor the latter, we could use a local average $m_i$ instead of a vector of counts\n\n$$\n \\begin{equation}\n m_i = \\frac{1}{|A(i)|} \\sum_{j \\in A(i)} g(s_j)\n \\end{equation}\n$$\n\nwhere $g(s)$ is a function that shapes the successional process. This is the same as our original formulation although the transitions must now be sequential. For state $k \\in \\{1,...,q-1\\}$,\n\n$$\n\\begin{equation}\n\\textbf{Pr}[s_i(t+1) = k + 1 \\ | \\ s_i(t) = k] = p_k(m_i) \n\\end{equation}\n$$\n\nwith $p_k(\\cdot)$ controlling the speed of succession across states. For example, this can be exponential or sigmoidal\n\n$$\n\\begin{align}\np_k(m_i) &= \\exp(\\nu_k + \\beta_km_i), \\qquad &\\text{Succession probability increases exponentially with local maturity.} \\\\\np_k(m_i) &= \\frac{1}{1 + \\exp[-(\\nu_k + \\beta_k m_i)]}, \\qquad &\\text{Succession probability increases sigmoidally and is bounded in }(0,1).\n\\end{align}\n$$\n\n## Disturbance and Update Rules \n\nWe allow $s_i < 1 \\le q$ to be probabilistically disturbed and set back to $s_i = 1$. Then, our update rules are as follows. If $k \\in \\{1,...,q-1\\}$, \n\n$$\n\\begin{align}\ns_i(t+1) = \n\\begin{cases} \n1   \\qquad &\\text{with }\\textbf{Pr}(d_k), \\\\ \nk+1 \\qquad &\\text{with }\\textbf{Pr}(1-d_k)p_k(m_i(t)), \\\\\nk   \\qquad &\\text{with }\\textbf{Pr}(1-d_k)[1 - p_k(m_i(t))]. \n\\end{cases} \n\\end{align}\n$$\nIf $k = q$, \n\n$$\n\\begin{align}\ns_i(t+1) =\n\\begin{cases}\n1 \\qquad &\\text{with }\\textbf{Pr}(d_q), \\\\\nq \\qquad &\\text{with }\\textbf{Pr}(1-d_q).\n\\end{cases}\n\\end{align}\n$$\n\n## Simulation \n\nTo simulate this system, we need some helper functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# logit^-1\ninv_logit = function(x) 1 / (1+exp(-x))\n\n# neighbor factory\nmake_neighbors = function(offsets, N) {\n  \n  function(i, j) {\n    ii = (i + offsets[,1] - 1) %% N + 1\n    jj = (j + offsets[,2] - 1) %% N + 1\n    cbind(ii, jj)\n  }\n}\n\n# disk function \ndisk_offsets = function(rd) {\n  disk = as.matrix(expand.grid(-rd:rd, -rd:rd))\n  disk = disk[rowSums(disk^2) <= rd^2 & rowSums(disk^2) > 0,]\n  return(disk)\n}\n```\n:::\n\n\nThen we set up the conditions. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nqstate_facilitation = function(\n    seed = NULL,\n    N     = 50,\n    q     = 4,\n    max_T = 500,\n    \n    nu    = c(-4,-3,-2),\n    beta  = c(0.8,0.4,0.2),\n    d     = c(0.001,0.001,0.001,0.001),\n    \n    rd    = 1 # neighborhood distance\n) {\n  \n  \n  set.seed(seed)\n  \n  offsets   = disk_offsets(rd)\n  neighbors = make_neighbors(offsets, N)\n  \n  # Initialize the matrix of states  \n  S = matrix(sample(1:q, N*N, replace = T), N, N)\n  \n  # Simulation \n  for(t in seq_len(max_T)) {\n    \n    i = sample.int(N, 1)\n    j = sample.int(N, 1)\n    k = S[i,j]\n    \n    nb  = neighbors(i,j)\n    m_i = mean(S[nb])\n    \n    # Disturbance \n    if(runif(1) < d[k]) {\n      S[i,j] = 1\n      next\n    }\n    \n    # Progression \n    if(k < q) {\n      p = inv_logit(nu[k] + beta[k]*m_i)\n      if(runif(1) < p) {\n        S[i,j] = k + 1\n      }\n    }\n  }\n  return(S)\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN = 100\nq = 2\nS = qstate_facilitation(N=N, q=2,\n                        nu=rep(0,q),\n                        beta=c(0.01,0.1),\n                        max_T = 50000, \n                        d = rep(0.1,q), \n                        seed=777)\n\nexpand.grid(i = 1:N, j = 1:N) |> \n  mutate(S = as.vector(S)) |> \n  ggplot(aes(i,j)) + \n  geom_tile(aes(fill=factor(S))) + \n  scale_fill_viridis_d() + \n  theme_void() + \n  theme(legend.position = 'none') +\n  coord_fixed()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}